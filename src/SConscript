import os
import copy

BIN_DIR=os.environ['BIN_DIR'];
LIB_DIR=os.environ['LIB_DIR'];
NANOVG_BACKEND=os.environ['NANOVG_BACKEND'];
VGCANVAS=os.environ['VGCANVAS'];
NATIVE_WINDOW = os.environ['NATIVE_WINDOW'];

sources=Glob('tkc/*.c') +\
  Glob('base/*.c') + \
  Glob('layouters/*.c') + \
  Glob('widgets/*.c') + \
  Glob('ui_loader/*.c') + \
  Glob('xml/*.c') + \
  Glob('svg/*.c') + \
  Glob('clip_board/*.c') + \
  Glob('font_loader/*.c') + \
  Glob('blend/*.c') + \
  Glob('ext_widgets/*.c') + \
  Glob('ext_widgets/*/*.c') + \
  Glob('image_loader/*.c') + \
  Glob('designer_support/*.c') + \
  Glob('widget_animators/*.c') + \
  Glob('misc/*.cpp') + \
  Glob('window_animators/*.c') + \
  Glob('dialog_highlighters/*.c') + \
  Glob('window_manager/window_manager_default.c') + \
  ['awtk_global.c'];

if NATIVE_WINDOW == 'sdl':
  sources += Glob('native_window/native_window_sdl.c')
else:
  sources += Glob('native_window/native_window_raw.c')

sources += ['lcd/lcd_mono.c'];
sources += ['main_loop/main_loop_simple.c'];
if os.environ['LCD'] == 'SDL_GPU':
  sources += ['lcd/lcd_nanovg.c', 'main_loop/main_loop_sdl.c'];
  sources += Glob('platforms/pc/*.c')
elif os.environ['LCD'] == 'SDL_FB':
  sources += ['lcd/lcd_sdl2.c', 'main_loop/main_loop_sdl.c']
  sources += Glob('platforms/pc/*.c')
elif os.environ['LCD'] == 'SDL_FB_MONO':
  sources += ['lcd/lcd_sdl2_mono.c', 'main_loop/main_loop_sdl.c']
  sources += Glob('platforms/pc/*.c')
elif os.environ['LCD'] == 'LINUX_FB':
  sources += Glob('platforms/pc/*.c')

sources += [
  'input_methods/input_method_creator.c'
  ] + Glob('lcd/lcd_mem_*.c') ;

if VGCANVAS == 'CAIRO':
  sources +=['vgcanvas/vgcanvas_cairo.c'];
else:
  if NANOVG_BACKEND == 'BGFX':
    sources +=['vgcanvas/vgcanvas_nanovg_bgfx.c'];
  elif NANOVG_BACKEND == 'AGG':
    sources +=['vgcanvas/vgcanvas_nanovg_soft.c'];
  elif NANOVG_BACKEND == 'AGGE':
    sources +=['vgcanvas/vgcanvas_nanovg_soft.c'];
  else:
    sources +=['vgcanvas/vgcanvas_nanovg_gl.c'];

if os.environ['INPUT_ENGINE'] == 'null':
  sources += Glob('input_engines/input_engine_null.c')
else:
  sources += Glob('input_engines/input_engine_pinyin.cpp')

env=DefaultEnvironment().Clone()

if env['PLATFORM'] == 'win32' and os.environ['TOOLS_NAME'] != '':
    import win32file
    import win32event
    import win32process
    import win32security

    def my_spawn(sh, escape, cmd, args, spawnenv):
        for var in spawnenv:
            spawnenv[var] = spawnenv[var].encode('ascii', 'replace')

        sAttrs = win32security.SECURITY_ATTRIBUTES()
        StartupInfo = win32process.STARTUPINFO()
        newargs = ' '.join(map(escape, args[1:]))
        cmdline = cmd + " " + newargs

        # check for any special operating system commands
        if cmd == 'del':
            for arg in args[1:]:
                win32file.DeleteFile(arg)
            exit_code = 0
        else:
            # otherwise execute the command.
            hProcess, hThread, dwPid, dwTid = win32process.CreateProcess(None, cmdline, None, None, 1, 0, spawnenv, None, StartupInfo)
            win32event.WaitForSingleObject(hProcess, win32event.INFINITE)
            exit_code = win32process.GetExitCodeProcess(hProcess)
            win32file.CloseHandle(hProcess);
            win32file.CloseHandle(hThread);
        return exit_code
    env['SPAWN'] = my_spawn
  
env.Library(os.path.join(LIB_DIR, 'awtk'), sources)

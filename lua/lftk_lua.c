/*XXX: generated by lua_gen. dont edit it.*/
#include "lua/lua.h"
#include "lua/lualib.h"
#include "lua/lauxlib.h"
#include "base/utf8.h"
#include "base/array.h"
#include "base/button.h"
#include "base/check_button.h"
#include "base/dialog.h"
#include "base/events.h"
#include "base/group_box.h"
#include "base/image.h"
#include "base/label.h"
#include "base/progress_bar.h"
#include "base/rect.h"
#include "base/resource_manager.h"
#include "base/theme.h"
#include "base/timer.h"
#include "base/types_def.h"
#include "base/value.h"
#include "base/widget.h"
#include "base/window_manager.h"
#include "base/window.h"
#include "src/lftk.h"

#include "custom.c"

static int wrap_button_t_get_prop(lua_State* L);
static int wrap_button_t_set_prop(lua_State* L);
static int wrap_check_button_t_get_prop(lua_State* L);
static int wrap_check_button_t_set_prop(lua_State* L);
static int wrap_dialog_t_get_prop(lua_State* L);
static int wrap_dialog_t_set_prop(lua_State* L);
static int wrap_event_t_get_prop(lua_State* L);
static int wrap_event_t_set_prop(lua_State* L);
static int wrap_pointer_event_t_get_prop(lua_State* L);
static int wrap_pointer_event_t_set_prop(lua_State* L);
static int wrap_key_event_t_get_prop(lua_State* L);
static int wrap_key_event_t_set_prop(lua_State* L);
static int wrap_group_box_t_get_prop(lua_State* L);
static int wrap_group_box_t_set_prop(lua_State* L);
static int wrap_image_t_get_prop(lua_State* L);
static int wrap_image_t_set_prop(lua_State* L);
static int wrap_label_t_get_prop(lua_State* L);
static int wrap_label_t_set_prop(lua_State* L);
static int wrap_progress_bar_t_get_prop(lua_State* L);
static int wrap_progress_bar_t_set_prop(lua_State* L);
static int wrap_point_t_get_prop(lua_State* L);
static int wrap_point_t_set_prop(lua_State* L);
static int wrap_rect_t_get_prop(lua_State* L);
static int wrap_rect_t_set_prop(lua_State* L);
static int wrap_value_t_get_prop(lua_State* L);
static int wrap_value_t_set_prop(lua_State* L);
static int wrap_widget_t_get_prop(lua_State* L);
static int wrap_widget_t_set_prop(lua_State* L);
static int wrap_window_t_get_prop(lua_State* L);
static int wrap_window_t_set_prop(lua_State* L);

static int wrap_lftk_quit(lua_State* L) {
  ret_t ret = 0;
  ret = (ret_t)lftk_quit();

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static void globals_init(lua_State* L) {
  lua_pushcfunction(L, wrap_lftk_quit);
  lua_setglobal(L, "lftk_quit");
  lua_pushcfunction(L, to_str);
  lua_setglobal(L, "to_str");
  lua_pushcfunction(L, to_wstr);
  lua_setglobal(L, "to_wstr");
}

static int wrap_button_create(lua_State* L) {
  widget_t* ret = NULL;
  widget_t* parent = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  xy_t x = (xy_t)luaL_checkinteger(L, 2);
  xy_t y = (xy_t)luaL_checkinteger(L, 3);
  wh_t w = (wh_t)luaL_checkinteger(L, 4);
  wh_t h = (wh_t)luaL_checkinteger(L, 5);
  ret = (widget_t*)button_create(parent, x, y, w, h);

  return lftk_newuserdata(L, ret, "/button_t/widget_t", "lftk.button_t");
}

static int wrap_button_set_text(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  wchar_t* text = (wchar_t*)lua_touserdata(L, 2);
  ret = (ret_t)button_set_text(widget, text);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}


static const struct luaL_Reg button_t_member_funcs[] = {
  {"set_text", wrap_button_set_text},
  {NULL, NULL}
};

static int wrap_button_t_set_prop(lua_State* L) {
  button_t* obj = (button_t*)lftk_checkudata(L, 1, "button_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  return wrap_widget_t_set_prop(L);
    printf("%s: not supported %s\n", __func__, name);
    return 0;
}

static int wrap_button_t_get_prop(lua_State* L) {
  button_t* obj = (button_t*)lftk_checkudata(L, 1, "button_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(button_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  else {
    return wrap_widget_t_get_prop(L);
  }
}

static void button_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {"create", wrap_button_create},
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_button_t_get_prop},
    {"__newindex", wrap_button_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.button_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "Button", static_funcs, 0);
  lua_settop(L, 0);
}
static int wrap_check_button_create(lua_State* L) {
  widget_t* ret = NULL;
  widget_t* parent = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  xy_t x = (xy_t)luaL_checkinteger(L, 2);
  xy_t y = (xy_t)luaL_checkinteger(L, 3);
  wh_t w = (wh_t)luaL_checkinteger(L, 4);
  wh_t h = (wh_t)luaL_checkinteger(L, 5);
  ret = (widget_t*)check_button_create(parent, x, y, w, h);

  return lftk_newuserdata(L, ret, "/check_button_t/widget_t", "lftk.check_button_t");
}

static int wrap_check_button_create_radio(lua_State* L) {
  widget_t* ret = NULL;
  widget_t* parent = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  xy_t x = (xy_t)luaL_checkinteger(L, 2);
  xy_t y = (xy_t)luaL_checkinteger(L, 3);
  wh_t w = (wh_t)luaL_checkinteger(L, 4);
  wh_t h = (wh_t)luaL_checkinteger(L, 5);
  ret = (widget_t*)check_button_create_radio(parent, x, y, w, h);

  return lftk_newuserdata(L, ret, "/check_button_t/widget_t", "lftk.check_button_t");
}

static int wrap_check_button_set_text(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  wchar_t* text = (wchar_t*)lua_touserdata(L, 2);
  ret = (ret_t)check_button_set_text(widget, text);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_check_button_set_value(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  uint32_t value = (uint32_t)luaL_checkinteger(L, 2);
  ret = (ret_t)check_button_set_value(widget, value);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}


static const struct luaL_Reg check_button_t_member_funcs[] = {
  {"set_text", wrap_check_button_set_text},
  {"set_value", wrap_check_button_set_value},
  {NULL, NULL}
};

static int wrap_check_button_t_set_prop(lua_State* L) {
  check_button_t* obj = (check_button_t*)lftk_checkudata(L, 1, "check_button_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  if(strcmp(name, "value") == 0) {
    printf("value is readonly\n");
    return 0;
  }
  else {
  return wrap_widget_t_set_prop(L);
  }
}

static int wrap_check_button_t_get_prop(lua_State* L) {
  check_button_t* obj = (check_button_t*)lftk_checkudata(L, 1, "check_button_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(check_button_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  if(strcmp(name, "value") == 0) {
    lua_pushboolean(L,(lua_Integer)(obj->value));

  return 1;
  }
  else {
    return wrap_widget_t_get_prop(L);
  }
}

static void check_button_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {"create", wrap_check_button_create},
    {"create_radio", wrap_check_button_create_radio},
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_check_button_t_get_prop},
    {"__newindex", wrap_check_button_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.check_button_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "CheckButton", static_funcs, 0);
  lua_settop(L, 0);
}
static int wrap_dialog_create(lua_State* L) {
  widget_t* ret = NULL;
  widget_t* parent = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  xy_t x = (xy_t)luaL_checkinteger(L, 2);
  xy_t y = (xy_t)luaL_checkinteger(L, 3);
  wh_t w = (wh_t)luaL_checkinteger(L, 4);
  wh_t h = (wh_t)luaL_checkinteger(L, 5);
  ret = (widget_t*)dialog_create(parent, x, y, w, h);

  return lftk_newuserdata(L, ret, "/dialog_t/widget_t", "lftk.dialog_t");
}

static int wrap_dialog_open(lua_State* L) {
  widget_t* ret = NULL;
  char* name = (char*)luaL_checkstring(L, 1);
  ret = (widget_t*)dialog_open(name);

  return lftk_newuserdata(L, ret, "/dialog_t/widget_t", "lftk.dialog_t");
}

static int wrap_dialog_set_icon(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  char* name = (char*)luaL_checkstring(L, 2);
  ret = (ret_t)dialog_set_icon(widget, name);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_dialog_set_title(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  wchar_t* title = (wchar_t*)lua_touserdata(L, 2);
  ret = (ret_t)dialog_set_title(widget, title);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_dialog_modal(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  ret = (ret_t)dialog_modal(widget);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_dialog_quit(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  uint32_t code = (uint32_t)luaL_checkinteger(L, 2);
  ret = (ret_t)dialog_quit(widget, code);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}


static const struct luaL_Reg dialog_t_member_funcs[] = {
  {"set_icon", wrap_dialog_set_icon},
  {"set_title", wrap_dialog_set_title},
  {"modal", wrap_dialog_modal},
  {"quit", wrap_dialog_quit},
  {NULL, NULL}
};

static int wrap_dialog_t_set_prop(lua_State* L) {
  dialog_t* obj = (dialog_t*)lftk_checkudata(L, 1, "dialog_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  return wrap_widget_t_set_prop(L);
    printf("%s: not supported %s\n", __func__, name);
    return 0;
}

static int wrap_dialog_t_get_prop(lua_State* L) {
  dialog_t* obj = (dialog_t*)lftk_checkudata(L, 1, "dialog_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(dialog_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  else {
    return wrap_widget_t_get_prop(L);
  }
}

static void dialog_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {"create", wrap_dialog_create},
    {"open", wrap_dialog_open},
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_dialog_t_get_prop},
    {"__newindex", wrap_dialog_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.dialog_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "Dialog", static_funcs, 0);
  lua_settop(L, 0);
}
static void event_type_t_init(lua_State* L) {
  lua_newtable(L);
  lua_setglobal(L, "EventType");
  lua_getglobal(L, "EventType");

  lua_pushstring(L, "NONE");
  lua_pushinteger(L, EVT_NONE);
  lua_settable(L, -3); 

  lua_pushstring(L, "POINTER_DOWN");
  lua_pushinteger(L, EVT_POINTER_DOWN);
  lua_settable(L, -3); 

  lua_pushstring(L, "POINTER_MOVE");
  lua_pushinteger(L, EVT_POINTER_MOVE);
  lua_settable(L, -3); 

  lua_pushstring(L, "POINTER_UP");
  lua_pushinteger(L, EVT_POINTER_UP);
  lua_settable(L, -3); 

  lua_pushstring(L, "POINTER_ENTER");
  lua_pushinteger(L, EVT_POINTER_ENTER);
  lua_settable(L, -3); 

  lua_pushstring(L, "POINTER_LEAVE");
  lua_pushinteger(L, EVT_POINTER_LEAVE);
  lua_settable(L, -3); 

  lua_pushstring(L, "CLICK");
  lua_pushinteger(L, EVT_CLICK);
  lua_settable(L, -3); 

  lua_pushstring(L, "KEY_DOWN");
  lua_pushinteger(L, EVT_KEY_DOWN);
  lua_settable(L, -3); 

  lua_pushstring(L, "KEY_UP");
  lua_pushinteger(L, EVT_KEY_UP);
  lua_settable(L, -3); 

  lua_pushstring(L, "MOVE");
  lua_pushinteger(L, EVT_MOVE);
  lua_settable(L, -3); 

  lua_pushstring(L, "RESIZE");
  lua_pushinteger(L, EVT_RESIZE);
  lua_settable(L, -3); 

  lua_pushstring(L, "DESTROY");
  lua_pushinteger(L, EVT_DESTROY);
  lua_settable(L, -3); 

  lua_pushstring(L, "MOVE_RESIZE");
  lua_pushinteger(L, EVT_MOVE_RESIZE);
  lua_settable(L, -3); 

  lua_pushstring(L, "PROP_CHANGED");
  lua_pushinteger(L, EVT_PROP_CHANGED);
  lua_settable(L, -3); 

}


static const struct luaL_Reg event_t_member_funcs[] = {
  {NULL, NULL}
};

static int wrap_event_t_set_prop(lua_State* L) {
  event_t* obj = (event_t*)lftk_checkudata(L, 1, "event_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  if(strcmp(name, "type") == 0) {
    printf("type is readonly\n");
    return 0;
  }
  else {
    printf("%s: not supported %s\n", __func__, name);
    return 0;
  }
}

static int wrap_event_t_get_prop(lua_State* L) {
  event_t* obj = (event_t*)lftk_checkudata(L, 1, "event_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(event_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  if(strcmp(name, "type") == 0) {
    lua_pushinteger(L,(lua_Integer)(obj->type));

  return 1;
  }
  else {
    printf("%s: not supported %s\n", __func__, name);
    return 0;
  }
}

static void event_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_event_t_get_prop},
    {"__newindex", wrap_event_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.event_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "Event", static_funcs, 0);
  lua_settop(L, 0);
}
static int wrap_pointer_event_cast(lua_State* L) {
  pointer_event_t* ret = NULL;
  event_t* event = (event_t*)lftk_checkudata(L, 1, "event_t");
  ret = (pointer_event_t*)pointer_event_cast(event);

  return lftk_newuserdata(L, ret, "/pointer_event_t/event_t", "lftk.pointer_event_t");
}


static const struct luaL_Reg pointer_event_t_member_funcs[] = {
  {NULL, NULL}
};

static int wrap_pointer_event_t_set_prop(lua_State* L) {
  pointer_event_t* obj = (pointer_event_t*)lftk_checkudata(L, 1, "pointer_event_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  if(strcmp(name, "x") == 0) {
    printf("x is readonly\n");
    return 0;
  }
  else if(strcmp(name, "y") == 0) {
    printf("y is readonly\n");
    return 0;
  }
  else if(strcmp(name, "button") == 0) {
    printf("button is readonly\n");
    return 0;
  }
  else if(strcmp(name, "pressed") == 0) {
    printf("pressed is readonly\n");
    return 0;
  }
  else {
  return wrap_event_t_set_prop(L);
  }
}

static int wrap_pointer_event_t_get_prop(lua_State* L) {
  pointer_event_t* obj = (pointer_event_t*)lftk_checkudata(L, 1, "pointer_event_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(pointer_event_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  if(strcmp(name, "x") == 0) {
    lua_pushnumber(L,(lua_Number)(obj->x));

  return 1;
  }
  else if(strcmp(name, "y") == 0) {
    lua_pushnumber(L,(lua_Number)(obj->y));

  return 1;
  }
  else if(strcmp(name, "button") == 0) {
    lua_pushinteger(L,(lua_Integer)(obj->button));

  return 1;
  }
  else if(strcmp(name, "pressed") == 0) {
    lua_pushboolean(L,(lua_Integer)(obj->pressed));

  return 1;
  }
  else {
    return wrap_event_t_get_prop(L);
  }
}

static void pointer_event_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {"cast", wrap_pointer_event_cast},
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_pointer_event_t_get_prop},
    {"__newindex", wrap_pointer_event_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.pointer_event_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "PointerEvent", static_funcs, 0);
  lua_settop(L, 0);
}
static int wrap_key_event_cast(lua_State* L) {
  key_event_t* ret = NULL;
  event_t* event = (event_t*)lftk_checkudata(L, 1, "event_t");
  ret = (key_event_t*)key_event_cast(event);

  return lftk_newuserdata(L, ret, "/key_event_t/event_t", "lftk.key_event_t");
}


static const struct luaL_Reg key_event_t_member_funcs[] = {
  {NULL, NULL}
};

static int wrap_key_event_t_set_prop(lua_State* L) {
  key_event_t* obj = (key_event_t*)lftk_checkudata(L, 1, "key_event_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  if(strcmp(name, "key") == 0) {
    printf("key is readonly\n");
    return 0;
  }
  else if(strcmp(name, "alt") == 0) {
    printf("alt is readonly\n");
    return 0;
  }
  else if(strcmp(name, "ctrl") == 0) {
    printf("ctrl is readonly\n");
    return 0;
  }
  else if(strcmp(name, "shift") == 0) {
    printf("shift is readonly\n");
    return 0;
  }
  else {
  return wrap_event_t_set_prop(L);
  }
}

static int wrap_key_event_t_get_prop(lua_State* L) {
  key_event_t* obj = (key_event_t*)lftk_checkudata(L, 1, "key_event_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(key_event_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  if(strcmp(name, "key") == 0) {
    lua_pushinteger(L,(lua_Integer)(obj->key));

  return 1;
  }
  else if(strcmp(name, "alt") == 0) {
    lua_pushboolean(L,(lua_Integer)(obj->alt));

  return 1;
  }
  else if(strcmp(name, "ctrl") == 0) {
    lua_pushboolean(L,(lua_Integer)(obj->ctrl));

  return 1;
  }
  else if(strcmp(name, "shift") == 0) {
    lua_pushboolean(L,(lua_Integer)(obj->shift));

  return 1;
  }
  else {
    return wrap_event_t_get_prop(L);
  }
}

static void key_event_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {"cast", wrap_key_event_cast},
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_key_event_t_get_prop},
    {"__newindex", wrap_key_event_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.key_event_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "KeyEvent", static_funcs, 0);
  lua_settop(L, 0);
}
static int wrap_group_box_create(lua_State* L) {
  widget_t* ret = NULL;
  widget_t* parent = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  xy_t x = (xy_t)luaL_checkinteger(L, 2);
  xy_t y = (xy_t)luaL_checkinteger(L, 3);
  wh_t w = (wh_t)luaL_checkinteger(L, 4);
  wh_t h = (wh_t)luaL_checkinteger(L, 5);
  ret = (widget_t*)group_box_create(parent, x, y, w, h);

  return lftk_newuserdata(L, ret, "/group_box_t/widget_t", "lftk.group_box_t");
}


static const struct luaL_Reg group_box_t_member_funcs[] = {
  {NULL, NULL}
};

static int wrap_group_box_t_set_prop(lua_State* L) {
  group_box_t* obj = (group_box_t*)lftk_checkudata(L, 1, "group_box_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  return wrap_widget_t_set_prop(L);
    printf("%s: not supported %s\n", __func__, name);
    return 0;
}

static int wrap_group_box_t_get_prop(lua_State* L) {
  group_box_t* obj = (group_box_t*)lftk_checkudata(L, 1, "group_box_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(group_box_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  else {
    return wrap_widget_t_get_prop(L);
  }
}

static void group_box_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {"create", wrap_group_box_create},
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_group_box_t_get_prop},
    {"__newindex", wrap_group_box_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.group_box_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "GroupBox", static_funcs, 0);
  lua_settop(L, 0);
}
static int wrap_image_create(lua_State* L) {
  widget_t* ret = NULL;
  widget_t* parent = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  xy_t x = (xy_t)luaL_checkinteger(L, 2);
  xy_t y = (xy_t)luaL_checkinteger(L, 3);
  wh_t w = (wh_t)luaL_checkinteger(L, 4);
  wh_t h = (wh_t)luaL_checkinteger(L, 5);
  ret = (widget_t*)image_create(parent, x, y, w, h);

  return lftk_newuserdata(L, ret, "/image_t/widget_t", "lftk.image_t");
}

static int wrap_image_set_image_name(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  char* name = (char*)luaL_checkstring(L, 2);
  ret = (ret_t)image_set_image_name(widget, name);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}


static const struct luaL_Reg image_t_member_funcs[] = {
  {"set_image_name", wrap_image_set_image_name},
  {NULL, NULL}
};

static int wrap_image_t_set_prop(lua_State* L) {
  image_t* obj = (image_t*)lftk_checkudata(L, 1, "image_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  return wrap_widget_t_set_prop(L);
    printf("%s: not supported %s\n", __func__, name);
    return 0;
}

static int wrap_image_t_get_prop(lua_State* L) {
  image_t* obj = (image_t*)lftk_checkudata(L, 1, "image_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(image_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  else {
    return wrap_widget_t_get_prop(L);
  }
}

static void image_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {"create", wrap_image_create},
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_image_t_get_prop},
    {"__newindex", wrap_image_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.image_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "Image", static_funcs, 0);
  lua_settop(L, 0);
}
static int wrap_label_create(lua_State* L) {
  widget_t* ret = NULL;
  widget_t* parent = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  xy_t x = (xy_t)luaL_checkinteger(L, 2);
  xy_t y = (xy_t)luaL_checkinteger(L, 3);
  wh_t w = (wh_t)luaL_checkinteger(L, 4);
  wh_t h = (wh_t)luaL_checkinteger(L, 5);
  ret = (widget_t*)label_create(parent, x, y, w, h);

  return lftk_newuserdata(L, ret, "/label_t/widget_t", "lftk.label_t");
}

static int wrap_label_set_border(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  uint8_t border = (uint8_t)luaL_checkinteger(L, 2);
  ret = (ret_t)label_set_border(widget, border);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_label_set_text_align_h(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  uint8_t text_align_h = (uint8_t)luaL_checkinteger(L, 2);
  ret = (ret_t)label_set_text_align_h(widget, text_align_h);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_label_set_text_align_v(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  uint8_t text_align_v = (uint8_t)luaL_checkinteger(L, 2);
  ret = (ret_t)label_set_text_align_v(widget, text_align_v);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_label_set_text(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  wchar_t* text = (wchar_t*)lua_touserdata(L, 2);
  ret = (ret_t)label_set_text(widget, text);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}


static const struct luaL_Reg label_t_member_funcs[] = {
  {"set_border", wrap_label_set_border},
  {"set_text_align_h", wrap_label_set_text_align_h},
  {"set_text_align_v", wrap_label_set_text_align_v},
  {"set_text", wrap_label_set_text},
  {NULL, NULL}
};

static int wrap_label_t_set_prop(lua_State* L) {
  label_t* obj = (label_t*)lftk_checkudata(L, 1, "label_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  if(strcmp(name, "border") == 0) {
    printf("border is readonly\n");
    return 0;
  }
  else if(strcmp(name, "text_align_v") == 0) {
    printf("text_align_v is readonly\n");
    return 0;
  }
  else if(strcmp(name, "text_align_h") == 0) {
    printf("text_align_h is readonly\n");
    return 0;
  }
  else {
  return wrap_widget_t_set_prop(L);
  }
}

static int wrap_label_t_get_prop(lua_State* L) {
  label_t* obj = (label_t*)lftk_checkudata(L, 1, "label_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(label_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  if(strcmp(name, "border") == 0) {
    lua_pushinteger(L,(lua_Integer)(obj->border));

  return 1;
  }
  else if(strcmp(name, "text_align_v") == 0) {
    lua_pushinteger(L,(lua_Integer)(obj->text_align_v));

  return 1;
  }
  else if(strcmp(name, "text_align_h") == 0) {
    lua_pushinteger(L,(lua_Integer)(obj->text_align_h));

  return 1;
  }
  else {
    return wrap_widget_t_get_prop(L);
  }
}

static void label_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {"create", wrap_label_create},
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_label_t_get_prop},
    {"__newindex", wrap_label_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.label_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "Label", static_funcs, 0);
  lua_settop(L, 0);
}
static int wrap_progress_bar_create(lua_State* L) {
  widget_t* ret = NULL;
  widget_t* parent = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  xy_t x = (xy_t)luaL_checkinteger(L, 2);
  xy_t y = (xy_t)luaL_checkinteger(L, 3);
  wh_t w = (wh_t)luaL_checkinteger(L, 4);
  wh_t h = (wh_t)luaL_checkinteger(L, 5);
  ret = (widget_t*)progress_bar_create(parent, x, y, w, h);

  return lftk_newuserdata(L, ret, "/progress_bar_t/widget_t", "lftk.progress_bar_t");
}

static int wrap_progress_bar_set_value(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  uint8_t value = (uint8_t)luaL_checkinteger(L, 2);
  ret = (ret_t)progress_bar_set_value(widget, value);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_progress_bar_set_vertical(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  bool_t vertical = (bool_t)lua_toboolean(L, 2);
  ret = (ret_t)progress_bar_set_vertical(widget, vertical);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_progress_bar_set_show_text(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  bool_t show_text = (bool_t)lua_toboolean(L, 2);
  ret = (ret_t)progress_bar_set_show_text(widget, show_text);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}


static const struct luaL_Reg progress_bar_t_member_funcs[] = {
  {"set_value", wrap_progress_bar_set_value},
  {"set_vertical", wrap_progress_bar_set_vertical},
  {"set_show_text", wrap_progress_bar_set_show_text},
  {NULL, NULL}
};

static int wrap_progress_bar_t_set_prop(lua_State* L) {
  progress_bar_t* obj = (progress_bar_t*)lftk_checkudata(L, 1, "progress_bar_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  if(strcmp(name, "value") == 0) {
    printf("value is readonly\n");
    return 0;
  }
  else if(strcmp(name, "vertical") == 0) {
    printf("vertical is readonly\n");
    return 0;
  }
  else if(strcmp(name, "show_text") == 0) {
    printf("show_text is readonly\n");
    return 0;
  }
  else {
  return wrap_widget_t_set_prop(L);
  }
}

static int wrap_progress_bar_t_get_prop(lua_State* L) {
  progress_bar_t* obj = (progress_bar_t*)lftk_checkudata(L, 1, "progress_bar_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(progress_bar_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  if(strcmp(name, "value") == 0) {
    lua_pushinteger(L,(lua_Integer)(obj->value));

  return 1;
  }
  else if(strcmp(name, "vertical") == 0) {
    lua_pushboolean(L,(lua_Integer)(obj->vertical));

  return 1;
  }
  else if(strcmp(name, "show_text") == 0) {
    lua_pushboolean(L,(lua_Integer)(obj->show_text));

  return 1;
  }
  else {
    return wrap_widget_t_get_prop(L);
  }
}

static void progress_bar_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {"create", wrap_progress_bar_create},
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_progress_bar_t_get_prop},
    {"__newindex", wrap_progress_bar_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.progress_bar_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "ProgressBar", static_funcs, 0);
  lua_settop(L, 0);
}

static const struct luaL_Reg point_t_member_funcs[] = {
  {NULL, NULL}
};

static int wrap_point_t_set_prop(lua_State* L) {
  point_t* obj = (point_t*)lftk_checkudata(L, 1, "point_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  if(strcmp(name, "x") == 0) {
    printf("x is readonly\n");
    return 0;
  }
  else if(strcmp(name, "y") == 0) {
    printf("y is readonly\n");
    return 0;
  }
  else {
    printf("%s: not supported %s\n", __func__, name);
    return 0;
  }
}

static int wrap_point_t_get_prop(lua_State* L) {
  point_t* obj = (point_t*)lftk_checkudata(L, 1, "point_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(point_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  if(strcmp(name, "x") == 0) {
    lua_pushnumber(L,(lua_Number)(obj->x));

  return 1;
  }
  else if(strcmp(name, "y") == 0) {
    lua_pushnumber(L,(lua_Number)(obj->y));

  return 1;
  }
  else {
    printf("%s: not supported %s\n", __func__, name);
    return 0;
  }
}

static void point_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_point_t_get_prop},
    {"__newindex", wrap_point_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.point_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "Point", static_funcs, 0);
  lua_settop(L, 0);
}

static const struct luaL_Reg rect_t_member_funcs[] = {
  {NULL, NULL}
};

static int wrap_rect_t_set_prop(lua_State* L) {
  rect_t* obj = (rect_t*)lftk_checkudata(L, 1, "rect_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  if(strcmp(name, "x") == 0) {
    printf("x is readonly\n");
    return 0;
  }
  else if(strcmp(name, "y") == 0) {
    printf("y is readonly\n");
    return 0;
  }
  else if(strcmp(name, "w") == 0) {
    printf("w is readonly\n");
    return 0;
  }
  else if(strcmp(name, "h") == 0) {
    printf("h is readonly\n");
    return 0;
  }
  else {
    printf("%s: not supported %s\n", __func__, name);
    return 0;
  }
}

static int wrap_rect_t_get_prop(lua_State* L) {
  rect_t* obj = (rect_t*)lftk_checkudata(L, 1, "rect_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(rect_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  if(strcmp(name, "x") == 0) {
    lua_pushnumber(L,(lua_Number)(obj->x));

  return 1;
  }
  else if(strcmp(name, "y") == 0) {
    lua_pushnumber(L,(lua_Number)(obj->y));

  return 1;
  }
  else if(strcmp(name, "w") == 0) {
    lua_pushnumber(L,(lua_Number)(obj->w));

  return 1;
  }
  else if(strcmp(name, "h") == 0) {
    lua_pushnumber(L,(lua_Number)(obj->h));

  return 1;
  }
  else {
    printf("%s: not supported %s\n", __func__, name);
    return 0;
  }
}

static void rect_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_rect_t_get_prop},
    {"__newindex", wrap_rect_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.rect_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "Rect", static_funcs, 0);
  lua_settop(L, 0);
}
static void align_v_t_init(lua_State* L) {
  lua_newtable(L);
  lua_setglobal(L, "AlignV");
  lua_getglobal(L, "AlignV");

  lua_pushstring(L, "NONE");
  lua_pushinteger(L, ALIGN_V_NONE);
  lua_settable(L, -3); 

  lua_pushstring(L, "MIDDLE");
  lua_pushinteger(L, ALIGN_V_MIDDLE);
  lua_settable(L, -3); 

  lua_pushstring(L, "TOP");
  lua_pushinteger(L, ALIGN_V_TOP);
  lua_settable(L, -3); 

  lua_pushstring(L, "BOTTOM");
  lua_pushinteger(L, ALIGN_V_BOTTOM);
  lua_settable(L, -3); 

}

static void align_h_t_init(lua_State* L) {
  lua_newtable(L);
  lua_setglobal(L, "AlignH");
  lua_getglobal(L, "AlignH");

  lua_pushstring(L, "NONE");
  lua_pushinteger(L, ALIGN_H_NONE);
  lua_settable(L, -3); 

  lua_pushstring(L, "CENTER");
  lua_pushinteger(L, ALIGN_H_CENTER);
  lua_settable(L, -3); 

  lua_pushstring(L, "LEFT");
  lua_pushinteger(L, ALIGN_H_LEFT);
  lua_settable(L, -3); 

  lua_pushstring(L, "RIGHT");
  lua_pushinteger(L, ALIGN_H_RIGHT);
  lua_settable(L, -3); 

}

static int wrap_timer_count(lua_State* L) {
  uint32_t ret = 0;
  ret = (uint32_t)timer_count();

  lua_pushinteger(L,(lua_Integer)(ret));

  return 1;
}

static void timer_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {"add", wrap_timer_add},
    {"remove", wrap_timer_remove},
    {"count", wrap_timer_count},
    {NULL, NULL}
  };

  luaL_openlib(L, "Timer", static_funcs, 0);
  lua_settop(L, 0);
}
static void ret_t_init(lua_State* L) {
  lua_newtable(L);
  lua_setglobal(L, "Ret");
  lua_getglobal(L, "Ret");

  lua_pushstring(L, "OK");
  lua_pushinteger(L, RET_OK);
  lua_settable(L, -3); 

  lua_pushstring(L, "OOM");
  lua_pushinteger(L, RET_OOM);
  lua_settable(L, -3); 

  lua_pushstring(L, "FAIL");
  lua_pushinteger(L, RET_FAIL);
  lua_settable(L, -3); 

  lua_pushstring(L, "QUIT");
  lua_pushinteger(L, RET_QUIT);
  lua_settable(L, -3); 

  lua_pushstring(L, "FOUND");
  lua_pushinteger(L, RET_FOUND);
  lua_settable(L, -3); 

  lua_pushstring(L, "REMOVE");
  lua_pushinteger(L, RET_REMOVE);
  lua_settable(L, -3); 

  lua_pushstring(L, "REPEAT");
  lua_pushinteger(L, RET_REPEAT);
  lua_settable(L, -3); 

  lua_pushstring(L, "NOT_FOUND");
  lua_pushinteger(L, RET_NOT_FOUND);
  lua_settable(L, -3); 

  lua_pushstring(L, "BAD_PARAMS");
  lua_pushinteger(L, RET_BAD_PARAMS);
  lua_settable(L, -3); 

}

static void value_type_t_init(lua_State* L) {
  lua_newtable(L);
  lua_setglobal(L, "ValueType");
  lua_getglobal(L, "ValueType");

  lua_pushstring(L, "INVALID");
  lua_pushinteger(L, VALUE_TYPE_INVALID);
  lua_settable(L, -3); 

  lua_pushstring(L, "BOOL");
  lua_pushinteger(L, VALUE_TYPE_BOOL);
  lua_settable(L, -3); 

  lua_pushstring(L, "INT8");
  lua_pushinteger(L, VALUE_TYPE_INT8);
  lua_settable(L, -3); 

  lua_pushstring(L, "UINT8");
  lua_pushinteger(L, VALUE_TYPE_UINT8);
  lua_settable(L, -3); 

  lua_pushstring(L, "INT16");
  lua_pushinteger(L, VALUE_TYPE_INT16);
  lua_settable(L, -3); 

  lua_pushstring(L, "UINT16");
  lua_pushinteger(L, VALUE_TYPE_UINT16);
  lua_settable(L, -3); 

  lua_pushstring(L, "INT32");
  lua_pushinteger(L, VALUE_TYPE_INT32);
  lua_settable(L, -3); 

  lua_pushstring(L, "UINT32");
  lua_pushinteger(L, VALUE_TYPE_UINT32);
  lua_settable(L, -3); 

  lua_pushstring(L, "INT64");
  lua_pushinteger(L, VALUE_TYPE_INT64);
  lua_settable(L, -3); 

  lua_pushstring(L, "UINT64");
  lua_pushinteger(L, VALUE_TYPE_UINT64);
  lua_settable(L, -3); 

  lua_pushstring(L, "POINTER");
  lua_pushinteger(L, VALUE_TYPE_POINTER);
  lua_settable(L, -3); 

  lua_pushstring(L, "FLOAT");
  lua_pushinteger(L, VALUE_TYPE_FLOAT);
  lua_settable(L, -3); 

  lua_pushstring(L, "DOUBLE");
  lua_pushinteger(L, VALUE_TYPE_DOUBLE);
  lua_settable(L, -3); 

  lua_pushstring(L, "STRING");
  lua_pushinteger(L, VALUE_TYPE_STRING);
  lua_settable(L, -3); 

  lua_pushstring(L, "WSTRING");
  lua_pushinteger(L, VALUE_TYPE_WSTRING);
  lua_settable(L, -3); 

}

static int wrap_value_set_bool(lua_State* L) {
  value_t* ret = NULL;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  bool_t value = (bool_t)lua_toboolean(L, 2);
  ret = (value_t*)value_set_bool(v, value);

  return lftk_newuserdata(L, ret, "/value_t", "lftk.value_t");
}

static int wrap_value_bool(lua_State* L) {
  bool_t ret = 0;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  ret = (bool_t)value_bool(v);

  lua_pushboolean(L,(lua_Integer)(ret));

  return 1;
}

static int wrap_value_set_int8(lua_State* L) {
  value_t* ret = NULL;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  int8_t value = (int8_t)luaL_checkinteger(L, 2);
  ret = (value_t*)value_set_int8(v, value);

  return lftk_newuserdata(L, ret, "/value_t", "lftk.value_t");
}

static int wrap_value_int8(lua_State* L) {
  int8_t ret = 0;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  ret = (int8_t)value_int8(v);

  lua_pushinteger(L,(lua_Integer)(ret));

  return 1;
}

static int wrap_value_set_uint8(lua_State* L) {
  value_t* ret = NULL;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  uint8_t value = (uint8_t)luaL_checkinteger(L, 2);
  ret = (value_t*)value_set_uint8(v, value);

  return lftk_newuserdata(L, ret, "/value_t", "lftk.value_t");
}

static int wrap_value_uint8(lua_State* L) {
  int8_t ret = 0;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  ret = (int8_t)value_uint8(v);

  lua_pushinteger(L,(lua_Integer)(ret));

  return 1;
}

static int wrap_value_set_int16(lua_State* L) {
  value_t* ret = NULL;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  int16_t value = (int16_t)luaL_checkinteger(L, 2);
  ret = (value_t*)value_set_int16(v, value);

  return lftk_newuserdata(L, ret, "/value_t", "lftk.value_t");
}

static int wrap_value_int16(lua_State* L) {
  int16_t ret = 0;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  ret = (int16_t)value_int16(v);

  lua_pushinteger(L,(lua_Integer)(ret));

  return 1;
}

static int wrap_value_set_uint16(lua_State* L) {
  value_t* ret = NULL;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  uint16_t value = (uint16_t)luaL_checkinteger(L, 2);
  ret = (value_t*)value_set_uint16(v, value);

  return lftk_newuserdata(L, ret, "/value_t", "lftk.value_t");
}

static int wrap_value_uint16(lua_State* L) {
  uint16_t ret = 0;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  ret = (uint16_t)value_uint16(v);

  lua_pushinteger(L,(lua_Integer)(ret));

  return 1;
}

static int wrap_value_set_int32(lua_State* L) {
  value_t* ret = NULL;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  int32_t value = (int32_t)luaL_checkinteger(L, 2);
  ret = (value_t*)value_set_int32(v, value);

  return lftk_newuserdata(L, ret, "/value_t", "lftk.value_t");
}

static int wrap_value_int32(lua_State* L) {
  int32_t ret = 0;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  ret = (int32_t)value_int32(v);

  lua_pushinteger(L,(lua_Integer)(ret));

  return 1;
}

static int wrap_value_set_uint32(lua_State* L) {
  value_t* ret = NULL;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  uint32_t value = (uint32_t)luaL_checkinteger(L, 2);
  ret = (value_t*)value_set_uint32(v, value);

  return lftk_newuserdata(L, ret, "/value_t", "lftk.value_t");
}

static int wrap_value_uint32(lua_State* L) {
  uint32_t ret = 0;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  ret = (uint32_t)value_uint32(v);

  lua_pushinteger(L,(lua_Integer)(ret));

  return 1;
}

static int wrap_value_set_int64(lua_State* L) {
  value_t* ret = NULL;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  int64_t value = (int64_t)luaL_checkinteger(L, 2);
  ret = (value_t*)value_set_int64(v, value);

  return lftk_newuserdata(L, ret, "/value_t", "lftk.value_t");
}

static int wrap_value_int64(lua_State* L) {
  int64_t ret = 0;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  ret = (int64_t)value_int64(v);

  lua_pushinteger(L,(lua_Integer)(ret));

  return 1;
}

static int wrap_value_set_uint64(lua_State* L) {
  value_t* ret = NULL;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  uint64_t value = (uint64_t)luaL_checkinteger(L, 2);
  ret = (value_t*)value_set_uint64(v, value);

  return lftk_newuserdata(L, ret, "/value_t", "lftk.value_t");
}

static int wrap_value_uint64(lua_State* L) {
  uint64_t ret = 0;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  ret = (uint64_t)value_uint64(v);

  lua_pushinteger(L,(lua_Integer)(ret));

  return 1;
}

static int wrap_value_set_float(lua_State* L) {
  value_t* ret = NULL;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  float value = (float)luaL_checknumber(L, 2);
  ret = (value_t*)value_set_float(v, value);

  return lftk_newuserdata(L, ret, "/value_t", "lftk.value_t");
}

static int wrap_value_float(lua_State* L) {
  float ret = 0;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  ret = (float)value_float(v);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_value_set_double(lua_State* L) {
  value_t* ret = NULL;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  double value = (double)luaL_checknumber(L, 2);
  ret = (value_t*)value_set_double(v, value);

  return lftk_newuserdata(L, ret, "/value_t", "lftk.value_t");
}

static int wrap_value_double(lua_State* L) {
  double ret = 0;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  ret = (double)value_double(v);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_value_set_str(lua_State* L) {
  value_t* ret = NULL;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  char* value = (char*)luaL_checkstring(L, 2);
  ret = (value_t*)value_set_str(v, value);

  return lftk_newuserdata(L, ret, "/value_t", "lftk.value_t");
}

static int wrap_value_str(lua_State* L) {
  const char* ret = NULL;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  ret = (const char*)value_str(v);

  lua_pushstring(L,(char*)(ret));

  return 1;
}

static int wrap_value_is_null(lua_State* L) {
  bool_t ret = 0;
  value_t* value = (value_t*)lftk_checkudata(L, 1, "value_t");
  ret = (bool_t)value_is_null(value);

  lua_pushboolean(L,(lua_Integer)(ret));

  return 1;
}

static int wrap_value_int(lua_State* L) {
  int ret = 0;
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  ret = (int)value_int(v);

  lua_pushinteger(L,(lua_Integer)(ret));

  return 1;
}

static int wrap_value_copy(lua_State* L) {
  value_t* dst = (value_t*)lftk_checkudata(L, 1, "value_t");
  value_t* src = (value_t*)lftk_checkudata(L, 2, "value_t");
  (void)value_copy(dst, src);

  return 0;
}

static int wrap_value_create(lua_State* L) {
  value_t* ret = NULL;
  ret = (value_t*)value_create();

  return lftk_newuserdata(L, ret, "/value_t", "lftk.value_t");
}

static int wrap_value_destroy(lua_State* L) {
  value_t* v = (value_t*)lftk_checkudata(L, 1, "value_t");
  (void)value_destroy(v);

  return 0;
}


static const struct luaL_Reg value_t_member_funcs[] = {
  {"set_bool", wrap_value_set_bool},
  {"bool", wrap_value_bool},
  {"set_int8", wrap_value_set_int8},
  {"int8", wrap_value_int8},
  {"set_uint8", wrap_value_set_uint8},
  {"uint8", wrap_value_uint8},
  {"set_int16", wrap_value_set_int16},
  {"int16", wrap_value_int16},
  {"set_uint16", wrap_value_set_uint16},
  {"uint16", wrap_value_uint16},
  {"set_int32", wrap_value_set_int32},
  {"int32", wrap_value_int32},
  {"set_uint32", wrap_value_set_uint32},
  {"uint32", wrap_value_uint32},
  {"set_int64", wrap_value_set_int64},
  {"int64", wrap_value_int64},
  {"set_uint64", wrap_value_set_uint64},
  {"uint64", wrap_value_uint64},
  {"set_float", wrap_value_set_float},
  {"float", wrap_value_float},
  {"set_double", wrap_value_set_double},
  {"double", wrap_value_double},
  {"set_str", wrap_value_set_str},
  {"str", wrap_value_str},
  {"is_null", wrap_value_is_null},
  {"int", wrap_value_int},
  {"copy", wrap_value_copy},
  {"destroy", wrap_value_destroy},
  {NULL, NULL}
};

static int wrap_value_t_set_prop(lua_State* L) {
  value_t* obj = (value_t*)lftk_checkudata(L, 1, "value_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  if(strcmp(name, "type") == 0) {
    printf("type is readonly\n");
    return 0;
  }
  else {
    printf("%s: not supported %s\n", __func__, name);
    return 0;
  }
}

static int wrap_value_t_get_prop(lua_State* L) {
  value_t* obj = (value_t*)lftk_checkudata(L, 1, "value_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(value_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  if(strcmp(name, "type") == 0) {
    lua_pushinteger(L,(lua_Integer)(obj->type));

  return 1;
  }
  else {
    printf("%s: not supported %s\n", __func__, name);
    return 0;
  }
}

static void value_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {"create", wrap_value_create},
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_value_t_get_prop},
    {"__newindex", wrap_value_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.value_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "Value", static_funcs, 0);
  lua_settop(L, 0);
}
static void widget_state_t_init(lua_State* L) {
  lua_newtable(L);
  lua_setglobal(L, "WidgetState");
  lua_getglobal(L, "WidgetState");

  lua_pushstring(L, "STATE_NONE");
  lua_pushinteger(L, WIDGET_STATE_NONE);
  lua_settable(L, -3); 

  lua_pushstring(L, "STATE_NORMAL");
  lua_pushinteger(L, WIDGET_STATE_NORMAL);
  lua_settable(L, -3); 

  lua_pushstring(L, "STATE_PRESSED");
  lua_pushinteger(L, WIDGET_STATE_PRESSED);
  lua_settable(L, -3); 

  lua_pushstring(L, "STATE_OVER");
  lua_pushinteger(L, WIDGET_STATE_OVER);
  lua_settable(L, -3); 

  lua_pushstring(L, "STATE_DISABLE");
  lua_pushinteger(L, WIDGET_STATE_DISABLE);
  lua_settable(L, -3); 

  lua_pushstring(L, "STATE_FOCUSED");
  lua_pushinteger(L, WIDGET_STATE_FOCUSED);
  lua_settable(L, -3); 

  lua_pushstring(L, "STATE_CHECKED");
  lua_pushinteger(L, WIDGET_STATE_CHECKED);
  lua_settable(L, -3); 

  lua_pushstring(L, "STATE_UNCHECKED");
  lua_pushinteger(L, WIDGET_STATE_UNCHECKED);
  lua_settable(L, -3); 

}

static void widget_type_t_init(lua_State* L) {
  lua_newtable(L);
  lua_setglobal(L, "WidgetType");
  lua_getglobal(L, "WidgetType");

  lua_pushstring(L, "WIDGET_NONE");
  lua_pushinteger(L, WIDGET_NONE);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_WINDOW_MANAGER");
  lua_pushinteger(L, WIDGET_WINDOW_MANAGER);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_NORMAL_WINDOW");
  lua_pushinteger(L, WIDGET_NORMAL_WINDOW);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_TOOL_BAR");
  lua_pushinteger(L, WIDGET_TOOL_BAR);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_DIALOG");
  lua_pushinteger(L, WIDGET_DIALOG);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_POPUP");
  lua_pushinteger(L, WIDGET_POPUP);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_SPRITE");
  lua_pushinteger(L, WIDGET_SPRITE);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_KEYBOARD");
  lua_pushinteger(L, WIDGET_KEYBOARD);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_DRAGGER");
  lua_pushinteger(L, WIDGET_DRAGGER);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_LABEL");
  lua_pushinteger(L, WIDGET_LABEL);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_BUTTON");
  lua_pushinteger(L, WIDGET_BUTTON);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_IMAGE");
  lua_pushinteger(L, WIDGET_IMAGE);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_EDIT");
  lua_pushinteger(L, WIDGET_EDIT);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_PROGRESS_BAR");
  lua_pushinteger(L, WIDGET_PROGRESS_BAR);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_GROUP_BOX");
  lua_pushinteger(L, WIDGET_GROUP_BOX);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_CHECK_BUTTON");
  lua_pushinteger(L, WIDGET_CHECK_BUTTON);
  lua_settable(L, -3); 

  lua_pushstring(L, "WIDGET_RADIO_BUTTON");
  lua_pushinteger(L, WIDGET_RADIO_BUTTON);
  lua_settable(L, -3); 

}

static int wrap_widget_count_children(lua_State* L) {
  uint32_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  ret = (uint32_t)widget_count_children(widget);

  lua_pushinteger(L,(lua_Integer)(ret));

  return 1;
}

static int wrap_widget_get_child(lua_State* L) {
  widget_t* ret = NULL;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  uint32_t index = (uint32_t)luaL_checkinteger(L, 2);
  ret = (widget_t*)widget_get_child(widget, index);

  return lftk_newuserdata(L, ret, "/widget_t", "lftk.widget_t");
}

static int wrap_widget_move(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  xy_t x = (xy_t)luaL_checkinteger(L, 2);
  xy_t y = (xy_t)luaL_checkinteger(L, 3);
  ret = (ret_t)widget_move(widget, x, y);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_resize(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  wh_t w = (wh_t)luaL_checkinteger(L, 2);
  wh_t h = (wh_t)luaL_checkinteger(L, 3);
  ret = (ret_t)widget_resize(widget, w, h);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_move_resize(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  xy_t x = (xy_t)luaL_checkinteger(L, 2);
  xy_t y = (xy_t)luaL_checkinteger(L, 3);
  wh_t w = (wh_t)luaL_checkinteger(L, 4);
  wh_t h = (wh_t)luaL_checkinteger(L, 5);
  ret = (ret_t)widget_move_resize(widget, x, y, w, h);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_set_value(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  uint32_t value = (uint32_t)luaL_checkinteger(L, 2);
  ret = (ret_t)widget_set_value(widget, value);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_set_text(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  wchar_t* text = (wchar_t*)lua_touserdata(L, 2);
  ret = (ret_t)widget_set_text(widget, text);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_get_value(lua_State* L) {
  uint32_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  ret = (uint32_t)widget_get_value(widget);

  lua_pushinteger(L,(lua_Integer)(ret));

  return 1;
}

static int wrap_widget_get_text(lua_State* L) {
  wchar_t* ret = NULL;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  ret = (wchar_t*)widget_get_text(widget);

  lua_pushlightuserdata(L,(void*)(ret));

  return 1;
}

static int wrap_widget_to_local(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  point_t* p = (point_t*)lftk_checkudata(L, 2, "point_t");
  ret = (ret_t)widget_to_local(widget, p);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_to_global(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  point_t* p = (point_t*)lftk_checkudata(L, 2, "point_t");
  ret = (ret_t)widget_to_global(widget, p);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_set_name(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  char* name = (char*)luaL_checkstring(L, 2);
  ret = (ret_t)widget_set_name(widget, name);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_set_enable(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  bool_t enable = (bool_t)lua_toboolean(L, 2);
  ret = (ret_t)widget_set_enable(widget, enable);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_set_focused(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  bool_t focused = (bool_t)lua_toboolean(L, 2);
  ret = (ret_t)widget_set_focused(widget, focused);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_set_state(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  widget_state_t state = (widget_state_t)luaL_checkinteger(L, 2);
  ret = (ret_t)widget_set_state(widget, state);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_destroy_children(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  ret = (ret_t)widget_destroy_children(widget);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_add_child(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  widget_t* child = (widget_t*)lftk_checkudata(L, 2, "widget_t");
  ret = (ret_t)widget_add_child(widget, child);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_remove_child(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  widget_t* child = (widget_t*)lftk_checkudata(L, 2, "widget_t");
  ret = (ret_t)widget_remove_child(widget, child);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_lookup(lua_State* L) {
  widget_t* ret = NULL;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  char* name = (char*)luaL_checkstring(L, 2);
  bool_t recursive = (bool_t)lua_toboolean(L, 3);
  ret = (widget_t*)widget_lookup(widget, name, recursive);

  return lftk_newuserdata(L, ret, "/widget_t", "lftk.widget_t");
}

static int wrap_widget_set_visible(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  bool_t visible = (bool_t)lua_toboolean(L, 2);
  bool_t recursive = (bool_t)lua_toboolean(L, 3);
  ret = (ret_t)widget_set_visible(widget, visible, recursive);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_invalidate(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  rect_t* r = (rect_t*)lftk_checkudata(L, 2, "rect_t");
  ret = (ret_t)widget_invalidate(widget, r);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_get_prop(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  char* name = (char*)luaL_checkstring(L, 2);
  value_t* v = (value_t*)lftk_checkudata(L, 3, "value_t");
  ret = (ret_t)widget_get_prop(widget, name, v);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_set_prop(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  char* name = (char*)luaL_checkstring(L, 2);
  value_t* v = (value_t*)lftk_checkudata(L, 3, "value_t");
  ret = (ret_t)widget_set_prop(widget, name, v);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_grab(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  widget_t* child = (widget_t*)lftk_checkudata(L, 2, "widget_t");
  ret = (ret_t)widget_grab(widget, child);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_ungrab(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  widget_t* child = (widget_t*)lftk_checkudata(L, 2, "widget_t");
  ret = (ret_t)widget_ungrab(widget, child);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}

static int wrap_widget_destroy(lua_State* L) {
  ret_t ret = 0;
  widget_t* widget = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  ret = (ret_t)widget_destroy(widget);

  lua_pushnumber(L,(lua_Number)(ret));

  return 1;
}


static const struct luaL_Reg widget_t_member_funcs[] = {
  {"count_children", wrap_widget_count_children},
  {"get_child", wrap_widget_get_child},
  {"move", wrap_widget_move},
  {"resize", wrap_widget_resize},
  {"move_resize", wrap_widget_move_resize},
  {"set_value", wrap_widget_set_value},
  {"set_text", wrap_widget_set_text},
  {"get_value", wrap_widget_get_value},
  {"get_text", wrap_widget_get_text},
  {"to_local", wrap_widget_to_local},
  {"to_global", wrap_widget_to_global},
  {"set_name", wrap_widget_set_name},
  {"set_enable", wrap_widget_set_enable},
  {"set_focused", wrap_widget_set_focused},
  {"set_state", wrap_widget_set_state},
  {"destroy_children", wrap_widget_destroy_children},
  {"add_child", wrap_widget_add_child},
  {"remove_child", wrap_widget_remove_child},
  {"lookup", wrap_widget_lookup},
  {"set_visible", wrap_widget_set_visible},
  {"on", wrap_widget_on},
  {"off", wrap_widget_off},
  {"on", wrap_widget_on},
  {"invalidate", wrap_widget_invalidate},
  {"get_prop", wrap_widget_get_prop},
  {"set_prop", wrap_widget_set_prop},
  {"grab", wrap_widget_grab},
  {"ungrab", wrap_widget_ungrab},
  {"destroy", wrap_widget_destroy},
  {NULL, NULL}
};

static int wrap_widget_t_set_prop(lua_State* L) {
  widget_t* obj = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  if(strcmp(name, "x") == 0) {
    printf("x is readonly\n");
    return 0;
  }
  else if(strcmp(name, "y") == 0) {
    printf("y is readonly\n");
    return 0;
  }
  else if(strcmp(name, "w") == 0) {
    printf("w is readonly\n");
    return 0;
  }
  else if(strcmp(name, "h") == 0) {
    printf("h is readonly\n");
    return 0;
  }
  else if(strcmp(name, "type") == 0) {
    printf("type is readonly\n");
    return 0;
  }
  else if(strcmp(name, "subtype") == 0) {
    printf("subtype is readonly\n");
    return 0;
  }
  else if(strcmp(name, "state") == 0) {
    printf("state is readonly\n");
    return 0;
  }
  else if(strcmp(name, "enable") == 0) {
    printf("enable is readonly\n");
    return 0;
  }
  else if(strcmp(name, "visible") == 0) {
    printf("visible is readonly\n");
    return 0;
  }
  else if(strcmp(name, "focused") == 0) {
    printf("focused is readonly\n");
    return 0;
  }
  else if(strcmp(name, "name") == 0) {
    printf("name is readonly\n");
    return 0;
  }
  else if(strcmp(name, "parent") == 0) {
    printf("parent is readonly\n");
    return 0;
  }
  else {
    printf("%s: not supported %s\n", __func__, name);
    return 0;
  }
}

static int wrap_widget_t_get_prop(lua_State* L) {
  widget_t* obj = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(widget_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  if(strcmp(name, "x") == 0) {
    lua_pushnumber(L,(lua_Number)(obj->x));

  return 1;
  }
  else if(strcmp(name, "y") == 0) {
    lua_pushnumber(L,(lua_Number)(obj->y));

  return 1;
  }
  else if(strcmp(name, "w") == 0) {
    lua_pushnumber(L,(lua_Number)(obj->w));

  return 1;
  }
  else if(strcmp(name, "h") == 0) {
    lua_pushnumber(L,(lua_Number)(obj->h));

  return 1;
  }
  else if(strcmp(name, "type") == 0) {
    lua_pushinteger(L,(lua_Integer)(obj->type));

  return 1;
  }
  else if(strcmp(name, "subtype") == 0) {
    lua_pushinteger(L,(lua_Integer)(obj->subtype));

  return 1;
  }
  else if(strcmp(name, "state") == 0) {
    lua_pushinteger(L,(lua_Integer)(obj->state));

  return 1;
  }
  else if(strcmp(name, "enable") == 0) {
    lua_pushboolean(L,(lua_Integer)(obj->enable));

  return 1;
  }
  else if(strcmp(name, "visible") == 0) {
    lua_pushboolean(L,(lua_Integer)(obj->visible));

  return 1;
  }
  else if(strcmp(name, "focused") == 0) {
    lua_pushboolean(L,(lua_Integer)(obj->focused));

  return 1;
  }
  else if(strcmp(name, "name") == 0) {
    lua_pushstring(L,(char*)(obj->name));

  return 1;
  }
  else if(strcmp(name, "parent") == 0) {
    return lftk_newuserdata(L, obj->parent, "/widget_t", "lftk.widget_t");
  }
  else {
    widget_t* child = widget_lookup(obj, name, FALSE);
    if(child != NULL) {
      return lftk_newuserdata(L, child, "/widget_t", "lftk.widget_t");
    }
    printf("%s: not supported %s\n", __func__, name);
    return 0;
  }
}

static void widget_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_widget_t_get_prop},
    {"__newindex", wrap_widget_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.widget_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "Widget", static_funcs, 0);
  lua_settop(L, 0);
}
static int wrap_window_create(lua_State* L) {
  widget_t* ret = NULL;
  widget_t* parent = (widget_t*)lftk_checkudata(L, 1, "widget_t");
  xy_t x = (xy_t)luaL_checkinteger(L, 2);
  xy_t y = (xy_t)luaL_checkinteger(L, 3);
  wh_t w = (wh_t)luaL_checkinteger(L, 4);
  wh_t h = (wh_t)luaL_checkinteger(L, 5);
  ret = (widget_t*)window_create(parent, x, y, w, h);

  return lftk_newuserdata(L, ret, "/window_t/widget_t", "lftk.window_t");
}

static int wrap_window_open(lua_State* L) {
  widget_t* ret = NULL;
  char* name = (char*)luaL_checkstring(L, 1);
  ret = (widget_t*)window_open(name);

  return lftk_newuserdata(L, ret, "/window_t/widget_t", "lftk.window_t");
}


static const struct luaL_Reg window_t_member_funcs[] = {
  {NULL, NULL}
};

static int wrap_window_t_set_prop(lua_State* L) {
  window_t* obj = (window_t*)lftk_checkudata(L, 1, "window_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  (void)obj;
  (void)name;
  return wrap_widget_t_set_prop(L);
    printf("%s: not supported %s\n", __func__, name);
    return 0;
}

static int wrap_window_t_get_prop(lua_State* L) {
  window_t* obj = (window_t*)lftk_checkudata(L, 1, "window_t");
  const char* name = (const char*)luaL_checkstring(L, 2);
  const luaL_Reg* ret = find_member(window_t_member_funcs, name);

  (void)obj;
  (void)name;
  if(ret) {
    lua_pushcfunction(L, ret->func);
    return 1;
  }
  else {
    return wrap_widget_t_get_prop(L);
  }
}

static void window_t_init(lua_State* L) {
  static const struct luaL_Reg static_funcs[] = {
    {"create", wrap_window_create},
    {"open", wrap_window_open},
    {NULL, NULL}
  };

  static const struct luaL_Reg index_funcs[] = {
    {"__index", wrap_window_t_get_prop},
    {"__newindex", wrap_window_t_set_prop},
    {NULL, NULL}
  };

  luaL_newmetatable(L, "lftk.window_t");
  lua_pushstring(L, "__index");
  lua_pushvalue(L, -2);
  lua_settable(L, -3);
  luaL_openlib(L, NULL, index_funcs, 0);
  luaL_openlib(L, "Window", static_funcs, 0);
  lua_settop(L, 0);
}

void luaL_openlftk(lua_State* L) {
  globals_init(L);
  button_t_init(L);
  check_button_t_init(L);
  dialog_t_init(L);
  event_type_t_init(L);
  event_t_init(L);
  pointer_event_t_init(L);
  key_event_t_init(L);
  group_box_t_init(L);
  image_t_init(L);
  label_t_init(L);
  progress_bar_t_init(L);
  point_t_init(L);
  rect_t_init(L);
  align_v_t_init(L);
  align_h_t_init(L);
  timer_t_init(L);
  ret_t_init(L);
  value_type_t_init(L);
  value_t_init(L);
  widget_state_t_init(L);
  widget_type_t_init(L);
  widget_t_init(L);
  window_t_init(L);
  s_current_L = L;
}
